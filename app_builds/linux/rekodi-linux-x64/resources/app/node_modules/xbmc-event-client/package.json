{
  "name": "xbmc-event-client",
  "description": "XBMC EventServer API Client using UDP sockets",
  "version": "0.0.2",
  "author": {
    "name": "Dave Eddy",
    "email": "dave@daveeddy.com",
    "url": "http://www.daveeddy.com"
  },
  "contributors": [],
  "repository": {
    "type": "git",
    "url": "git://github.com/bahamas10/node-xbmc-event-client.git"
  },
  "scripts": {
    "test": "for f in test/*.js; do echo \"\n$f\"; node \"$f\" || exit 1; sleep 2; done; echo Passed; exit 0"
  },
  "main": "./xbmc-event-client.js",
  "dependencies": {},
  "bin": {},
  "devDependencies": {},
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "keywords": [
    "xbmc",
    "xbox",
    "event",
    "udp"
  ],
  "readme": "Node.JS XBMCEventClient\n=======================\n\nXBMC EventServer API Client using UDP sockets\n\nUsage\n-----\n\n### Simple\n\n``` js\nvar XBMCEventClient = require('xbmc-event-client').XBMCEventClient;\nvar xbmc = new XBMCEventClient('node.js app');\n\nxbmc.connect(function(errors, bytes) {\n  if (errors.length)\n    throw errors[0];\n\n  xbmc.notification('Title', 'Hello from node!');\n  xbmc.keyPress('enter');\n  xbmc.log('this will show up in xbmc.log');\n\n  setTimeout(function() {\n    xbmc.close();\n  }, 1000);\n});\n```\n\n### Advanced\n\n``` js\nvar fs = require('fs');\nvar path = require('path');\n\nvar xec = require('xbmc-event-client');\n\nvar opts = {\n  log: true,\n  icontype: xec.ICON_PNG,\n  iconbuffer: fs.readFileSync('./node.png'),\n  host: '192.168.1.50',\n  port: 9777\n};\n\nvar xbmc = new xec.XBMCEventClient(name, opts);\n\nxbmc.connect(function(errors, bytes) {\n  if (errors.length)\n    throw errors[0];\n\n  xbmc.notification(title, message, function(errors, bytes) {\n    if (errors.length)\n      throw errors[0];\n\n    xbmc.close();\n  });\n});\n```\n\nAPI\n---\n\nUse the high-level `XBMCEventClient` API for easy XBMC communication\n\n### `new XBMCEventClient(name, opts={})`\n\nCreate a new `XBMCEventClient` object.\n\n- `name`: used to identify the client to XBMC, sent in the `HELO` packet\n- `opts` [optional]\n  - `opts.host`: XBMC host to connect to, defaults to `localhost`\n  - `opts.port`: XBMC port to connect to, defaults to `9777`\n  - `opts.log`: log sent packet notifications to stderr, defaults to `false`\n  - `opts.iconbuffer`: optional buffer of icon data to send for notificationss\n  - `opts.icontype`: optional icon type if `opts.iconbuffer` is supplied, see\n  [constants.js](/lib/constants.js) for possible values\n\n---\n\nAll functions below take a callback function as their last argument.  The callback\nwill be fired when all UDP packets have been sent to the server, and will\nbe passed 2 arguments.\n\n``` js\nfunction(errors, bytes) {}\n```\n\nThe firest argument is an array of `new Error` objects (if any errors happened),\nand the second is an array of the bytes sent to the server.  Checking the length\nof `errors` is sufficient for determining if an error occurred when sending the\npacket(s).\n\n---\n\n### `xbmc.connect(cb=function() {})`\n\nConnect to XBMC by sending a `HELO` packet\n\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.ping(cb=function() {})`\n\nKeep the \"connection\" alive by sending a `PING` packet.\nNote that a conncection is considered idle after 60 seconds\nof inactivity, so consider adding an interval to continually ping\nthe server.\n\n``` js\nsetInterval(xbmc.ping.bind(xbmc), 55 * 1000);\n```\n\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.log(message, loglevel=xec.LOGDEBUG, cb=function() {})`\n\nLog a message on XBMC to `xbmc.log`\n\n- `message`: the message to log on the server\n- `loglevel`: [optional] the log level to use, see [constants.js](/lib/constants.js) for possible values\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.notification(title, message, icontype=undefined, iconbuffer=undefined, cb=function() {})`\n\nSend an OSD notification to XBMC\n\n- `title`: title of the notification\n- `message`: message in the notification\n- `icontype`: [optional] icon type if `iconbuffer` is supplied, see [constants.js](/lib/constants.js) for possible values\n- `iconbuffer`: [optional] buffer of icon data to send for notificationss\n- `cb`: [optional] callback function to fire when all packets are sent\n\nIf `icontype` and `iconbuffer` were given in the constructor, they will be used\nautomatically for this function.\n\n### `xbmc.mouse(x, y, cb=function() {})`\n\nSet the mouse position to the given X and Y positions\n\n- `x`: mouse X position, 0 <= `x` <= 65535\n- `y`: mouse Y position, 0 <= `y` <= 65535\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.keyPress(name, cb=function() {})`\n\nTrigger a single key press event using the keyboard keymap\n\n- `name`: keyname name, like `enter`, `up`, `escape`, etc.\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.keyDown(name, cb=function() {})`\n\nSet the state of a key to down\n\n- `name`: keyname name, like `enter`, `up`, `escape`, etc.\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.keyUp(name, cb=function() {})`\n\nSet the state of a key to up\n\n- `name`: keyname name, like `enter`, `up`, `escape`, etc.\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.remotePress(name, cb=function() {})`\n\nTrigger a single remote press event using the remote keymap\n\n- `name`: keyname name, like `play`, `menu`, `left`, etc.\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.remoteDown(name, cb=function() {})`\n\nSet the state of a remote key to down\n\n- `name`: keyname name, like `play`, `menu`, `left`, etc.\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.remoteUp(name, cb=function() {})`\n\nSet the state of a remote key to up\n\n- `name`: keyname name, like `play`, `menu`, `left`, etc.\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.buttonPress(map, button, cb=function() {})`\n\nTrigger a single press event for the `button` found in keymap `map`\n\n- `map`: keymap file\n- `button`: button name\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.buttonDown(map, button, cb=function() {})`\n\nSet the state for the `button` found in keymap `map` to down\n\n- `map`: keymap file\n- `button`: button name\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.buttonUp(map, button, cb=function() {})`\n\nSet the state for the `button` found in keymap `map` to up\n\n- `map`: keymap file\n- `button`: button name\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.releaseAll(cb=function() {})`\n\nRelease all buttons pressed (set the state of all buttons to up)\n\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.buttonState(state, cb=function() {})`\n\nSet button state\n\n- `state`:\n  - `state.map`: [string] keymap to use, defaults to `undefined`\n  - `state.button`: [string] button name if `state.map` is set, defaults to `undefined`\n  - `state.code`: [int] button code, defaults to `undefined`\n  - `state.down`: [boolean] the button is pushed down, defaults to `true`\n  - `state.queue`: [boolean] queue is specified, defaults to `false`\n  - `state.repeat`: [boolean] the button should repeat, defaults to `true`\n  - `state.amount`: [int] amount button is pushed, 0 <= `amount` <= 65535, defaults to `0`\n  - `state.axis`: [int] number of axis, defaults to `0`\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.disconnect(cb=function() {})`\n\nSend a `BYE` packet to the server and close the underlying UDP socket\n\n- `cb`: [optional] callback function to fire when all packets are sent\n\n### `xbmc.send(packet, cb=function() {})`\n\nInternal function used for sending a `new Packet()` object to XBMC\n\n- `cb`: [optional] callback function to fire when all packets are sent\n\nLow Level API\n-------------\n\nAlso exposed in this module is the generic `Packet` class, as well as\nthe specific subclasses like `PacketHELO`, `PacketBUTTON`, `PacketPING`, etc.\nclasses.\n\nFor more information on these classes and how to use them see the [lib/](/lib/)\ndirectory\n\nInstallation\n------------\n\n    npm install xbmc-event-client\n\nTests\n-----\n\nRun `npm test` to run the tests, using environmental variables to account\nfor your environment, ex.\n\n    $ XBMC_HOST=192.168.1.2 npm test\n\nLicense\n-------\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/bahamas10/node-xbmc-event-client/issues"
  },
  "homepage": "https://github.com/bahamas10/node-xbmc-event-client",
  "_id": "xbmc-event-client@0.0.2",
  "dist": {
    "shasum": "25f270d1c94750745221738cd32fa6d61be94caf",
    "tarball": "http://registry.npmjs.org/xbmc-event-client/-/xbmc-event-client-0.0.2.tgz"
  },
  "_from": "xbmc-event-client@0.0.2",
  "_npmVersion": "1.3.11",
  "_npmUser": {
    "name": "bahamas10",
    "email": "dave@daveeddy.com"
  },
  "maintainers": [
    {
      "name": "bahamas10",
      "email": "dave@daveeddy.com"
    }
  ],
  "directories": {},
  "_shasum": "25f270d1c94750745221738cd32fa6d61be94caf",
  "_resolved": "https://registry.npmjs.org/xbmc-event-client/-/xbmc-event-client-0.0.2.tgz"
}
